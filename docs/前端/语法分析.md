# 语法分析

> 作者：zxw
> 
> 最近一次更新于2025/3/23

Parser类定义于`include/Frontend/Parser.h`，实现于`src/Frontend/Parser.cpp`。

Parser使用的语法树AST类定义于`include/Utils/AST.h`。

## AST

抽象语法树类`AST`位于`namespace AST`下。

每个语法成分都可以抽象为结点，定义结点抽象基类`Node`如下：
```cpp
// AST 结点基类
class Node {
public:
    virtual ~Node() = default;

    [[nodiscard]] virtual std::string to_string() const = 0;
};
```

Sysy语言的定义如下：

![](https://drinkwater-1325041233.cos.ap-guangzhou.myqcloud.com/imgs/20250323130838.png)

![](https://drinkwater-1325041233.cos.ap-guangzhou.myqcloud.com/imgs/20250323130901.png)

或者，使用Antlr4的g4（grammar）文件，可将Sysy语言的定义表示如下：

```
grammar SysY2022;

// 主规则
compUnit: (decl | funcDef)* EOF;

// 声明部分
decl: constDecl | varDecl;
constDecl: 'const' bType=('int' | 'float') constDef[$bType.text] (',' constDef[$bType.text])* ';';
varDecl: bType=('int' | 'float') varDef[$bType.text] (',' varDef[$bType.text])* ';';

// 常量定义
constDef[String type]: IDENT ('[' constExp ']')* '=' constInitVal;
constInitVal: constExp | '{' (constInitVal (',' constInitVal)*)? '}';

// 变量定义
varDef[String type]: IDENT ('[' constExp ']')* ('=' initVal)?;
initVal: exp | '{' (initVal (',' initVal)*)? '}';

// 函数定义
funcDef: funcType=('void' | 'int' | 'float') IDENT '(' funcFParams? ')' block;
funcFParams: funcFParam (',' funcFParam)*;
funcFParam: bType=('int' | 'float') IDENT ('[' ']' ('[' exp ']')*)?;

// 语句块和语句
block: '{' blockItem* '}';
blockItem: decl | stmt;
stmt: lVal '=' exp ';'                            # assignStmt
    | exp? ';'                                    # expStmt
    | block                                       # blockStmt
    | 'if' '(' cond ')' stmt ('else' stmt)?       # ifStmt
    | 'while' '(' cond ')' stmt                   # whileStmt
    | 'break' ';'                                 # breakStmt
    | 'continue' ';'                              # continueStmt
    | 'return' exp? ';'                           # returnStmt
    ;

// 表达式部分
exp: addExp | StringConst;
cond: lOrExp;
lVal: IDENT ('[' exp ']')*;
primaryExp: '(' exp ')' | lVal | number;
number: FLOAT_NUMBER | HEX_CONST | OCT_CONST | INT_CONST;
unaryExp: primaryExp | IDENT '(' funcRParams? ')' | unaryOp unaryExp;
unaryOp: ADD | SUB | NOT;
funcRParams: exp (',' exp)*;
mulExp: unaryExp (op=(MUL | DIV | MOD) unaryExp)*;
addExp: mulExp (op=(ADD | SUB) mulExp)*;
relExp: addExp (op=(LE | GE | LT | GT) addExp)*;
eqExp: relExp (op=(EQ | NE) relExp)*;
lAndExp: eqExp (AND eqExp)*;
lOrExp: lAndExp (OR lAndExp)*;
constExp: addExp;

// 词法定义
IDENT: [a-zA-Z_][a-zA-Z_0-9]*;
ADD: '+';
SUB: '-';
NOT: '!';
MUL: '*';
DIV: '/';
MOD: '%';
LT: '<';
GT: '>';
LE: '<=';
GE: '>=';
EQ: '==';
NE: '!=';
AND: '&&';
OR: '||';

// 支持十进制、十六进制和八进制整数
INT_CONST: '0' | [1-9][0-9]*;
HEX_CONST: '0x' [0-9a-fA-F]+ | '0X' [0-9a-fA-F]+;
OCT_CONST: '0' [0-7]+;

// 浮点数定义
FLOAT_NUMBER
    : DecimalFloatingConstant
    | HexadecimalFloatingConstant
    ;

// 十进制浮点数
fragment DecimalFloatingConstant
    : FractionalConstant ExponentPart? FloatingSuffix?
    | DigitSequence ExponentPart FloatingSuffix?
    ;

// 十六进制浮点数
fragment HexadecimalFloatingConstant
    : HexadecimalPrefix HexadecimalFractionalConstant BinaryExponentPart FloatingSuffix?
    | HexadecimalPrefix HexadecimalDigitSequence BinaryExponentPart FloatingSuffix?
    ;

// 分数常量
fragment FractionalConstant
    : DigitSequence? '.' DigitSequence
    | DigitSequence '.'
    ;

// 十进制指数部分
fragment ExponentPart
    : [eE] Sign? DigitSequence
    ;

// 二进制指数部分
fragment BinaryExponentPart
    : [pP] Sign? DigitSequence
    ;

// 符号
fragment Sign
    : '+' | '-'
    ;

// 十进制数字序列
fragment DigitSequence
    : Digit+
    ;

// 十六进制分数常量
fragment HexadecimalFractionalConstant
    : HexadecimalDigitSequence? '.'
    | HexadecimalDigitSequence '.'
    ;

// 十六进制数字序列
fragment HexadecimalDigitSequence
    : HexadecimalDigit+
    ;

// 十六进制前缀
fragment HexadecimalPrefix
    : '0' [xX]
    ;

// 浮点数后缀
fragment FloatingSuffix
    : [fF] | [lL]
    ;

// 数字
fragment Digit
    : [0-9]
    ;

// 十六进制数字
fragment HexadecimalDigit
    : [0-9a-fA-F]
    ;

// 字符串常量
StringConst: '"' (~["\\] | '\\' .)* '"' ;

// 空白符和注释
WS: [ \t\r\n]+ -> skip;
LINE_COMMENT: '//' ~[\r\n]* -> skip;
BLOCK_COMMENT: '/*' .*? '*/' -> skip;
```

对于形如`PrimaryExp -> '(' Exp ')' | LVal | Number`的语法规则，在`PrimaryExp`类使用`std::variant`存储可变类型，并配备`is_{exp|lVal|number}`方法来判断`PrimaryExp`所存储的子结点的具体类型。

```cpp
// PrimaryExp -> '(' Exp ')' | LVal | Number
class PrimaryExp final : public Node {
    const std::variant<std::shared_ptr<Exp>, std::shared_ptr<LVal>, std::shared_ptr<Number>> value_;

public:
    explicit PrimaryExp(const std::shared_ptr<Exp> &exp) : value_{exp} {}

    explicit PrimaryExp(const std::shared_ptr<LVal> &lVal) : value_{lVal} {}

    explicit PrimaryExp(const std::shared_ptr<Number> &number) : value_{number} {}

    [[nodiscard]] std::variant<std::shared_ptr<Exp>, std::shared_ptr<LVal>,
        std::shared_ptr<Number>> get_value() const { return value_; }

    [[nodiscard]] bool is_exp() const {
        return std::holds_alternative<std::shared_ptr<Exp>>(value_);
    }

    [[nodiscard]] bool is_lVal() const {
        return std::holds_alternative<std::shared_ptr<LVal>>(value_);
    }

    [[nodiscard]] bool is_number() const {
        return std::holds_alternative<std::shared_ptr<Number>>(value_);
    }

    [[nodiscard]] std::string to_string() const override;
};
```

该类的一种使用方法如下：
```cpp
// Builder.cpp
std::shared_ptr<Value> Builder::visit_primaryExp(const std::shared_ptr<AST::PrimaryExp> &primaryExp) const {
    if (primaryExp->is_number()) {
        return visit_number(std::get<std::shared_ptr<AST::Number>>(primaryExp->get_value()));
    }
    if (primaryExp->is_lVal()) {
        return visit_lVal(std::get<std::shared_ptr<AST::LVal>>(primaryExp->get_value()));
    }
    if (primaryExp->is_exp()) {
        return visit_exp(std::get<std::shared_ptr<AST::Exp>>(primaryExp->get_value()));
    }
    log_fatal("Invalid primaryExp");
}
```

## Parser

语法分析器类Parser的主要任务是递归下降，分析所有语法成分，构造AST。

在Parser中，每一个类都具有一个parse方法，如`parseDecl`，`parseWhileStmt`等。

### 接口

Parser在`Compiler.cpp`的接口为`parse`，定义与使用方法如下：
```cpp
// Parser.h
std::shared_ptr<AST::CompUnit> parse() {
    return parseCompUnit();
}

// Compiler.cpp
const std::vector<Token::Token> &tokens = lexer.tokenize();

Parser parser(tokens);
std::shared_ptr<AST::CompUnit> ast = parser.parse();
```

Parse接受Token列表构建语法树，返回一个`std::shared_ptr<AST::CompUnit>`，为语法树的根节点。

### 实现

Parser类中定义了两个模板函数用于判断当前位置的token是否为预期的type。
```cpp
template<typename... Types>
bool Parser::panic_on(Types... expected_types) {
    std::unordered_set<Token::Type> types = {expected_types...};
    if (const Token::Type current_type = peek().type; types.find(current_type) == types.end()) {
        std::ostringstream oss;
        oss << "Expected one of { ";
        for (const auto &type: types) {
            oss << type_to_string(type) << " ";
        }
        oss << "}, got Token " << type_to_string(current_type) << " at line " << peek().line;
        log_fatal(oss.str().c_str());
    }
    pos++;
    return true;
}

template<typename... Types>
bool Parser::match(Types... expected_types) {
    std::unordered_set<Token::Type> types = {expected_types...};
    if (const Token::Type current_type = peek().type; types.find(current_type) == types.end()) return false;
    pos++;
    return true;
}
```

`panic`函数在当前token的type不适于任何一个`expected_types`时，会发生`fatal`异常，而`match`方法不会。

`panic`和`match`的一个使用示例如下：

```cpp
// constDef[String type]: IDENT ('[' constExp ']')* '=' constInitVal;
std::shared_ptr<AST::ConstDef> Parser::parseConstDef() {
    panic_on(Token::Type::IDENTIFIER);
    const std::string ident = next(-1).content;
    std::vector<std::shared_ptr<AST::ConstExp>> constExps;
    if (match(Token::Type::LBRACKET)) {
        do {
            constExps.emplace_back(parseConstExp());
            panic_on(Token::Type::RBRACKET);
        } while (match(Token::Type::LBRACKET));
    }
    panic_on(Token::Type::ASSIGN);
    std::shared_ptr<AST::ConstInitVal> constInitVal = parseConstInitVal();
    return std::make_shared<AST::ConstDef>(ident, constExps, constInitVal);
}
```