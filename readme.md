# SHIT-Compiler
SysY 语言编译器，计算机系统能力大赛编译系统设计赛（华为毕昇杯）参赛作品。

## 构建
```bash
# 在根目录下执行
mkdir build && cd build
cmake .. -D CMAKE_BUILD_TYPE={Debug, Release, RelWithDebInfo} # 设定优化等级
make -j 4
# 构建好的目标为../bin/compiler
```

在Debug模式下，定义了宏 `-DSHIT_DEBUG` ，设置日志输出等级为 `TRACE`；默认情况下为 `INFO`。

## 命令行使用方法

```bash
./compiler 输入文件 [选项]
```

Debug模式下，会载入默认数据，方便开发：
```c++
compiler_options debug_compile_options = {
    .input_file = "../testcase.sy",
    .flag_S = true,
    .output_file = "../testcase.s",
    ._emit_options = {.emit_tokens = false, .emit_ast = false, .emit_llvm = true},
    .opt_level = Optimize_level::O0
};
```

### 必需参数

- `输入文件`：源代码文件路径（使用 .sy 扩展名）

### 可选参数

#### 输出控制
- `-S`：生成汇编代码输出
- `-o <文件>`：指定汇编输出文件（默认为：输入文件名.s）

#### 优化选项
- `-O0`：不进行优化（默认选项）
- `-O1`：基础优化
- `-O2`：高级优化

#### 中间表示输出
- `-emit-tokens [<文件>]`：输出词法标记
- `-emit-ast [<文件>]`：输出抽象语法树
- `-emit-llvm [<文件>]`：输出 LLVM IR（默认为：输入文件名.ll）

对于所有的 emit 选项，如果不指定输出文件，将直接输出到标准输出（stdout）。

## 前端设计

我们的前端设计总体而言分为词法分析、语法分析和语义分析三个部分。

`stoptime`和`starttime`的参数需要行号，因此我们在token中设置属性行号，并且设置静态变量`line`，每次读取到一个`\n`就将其加一。

建立语法树需要进行词法分析，我们用一个parser进行递归下降来解决问题。经过语法分析后，得到了一个由语法单元组成的AST(抽象语法树)，便于后续向中端代码转化。

在建立语法树的过程中，我们在AST.h文件夹定义了语法树的各个节点和操作方式。

在语义分析中，为了维护浮点数的精度问题，我们定义了SimpleFloat类，按照ieee标准存储。

## 中端设计

### 数据结构

我们采用了llvm推荐的架构，采用一个Value基类，所有的值都继承自Value类。

在我们的设计中，每一个指令都与一个基本块相绑定，这样可以正确地反映它和基本块之间的对应关系。同时针对所有value都设置了类型属性，包括：基本属性：`BaseType`和其衍生子类:`I1,I32,I64,F32`，指针类`PointerType`和以其所指value类型为依据划分的其他各种type，数组类`ArrayType`。这样的type体系方便对value进行针对性的判断，方便采取不同的执行措施。

需要注意的是，在我们的中端设计中，依然采取类似前端AST一样的递归架构。指令使用Value，同时指令本身也是Value，该value代表指令执行的结果。

### 循环(Loop)

循环一直是中端控制流的重点与优化的重中之重，因此我们在设计的时候就将循环作为中端的一个基本类来设计实现。通过计算支配关系，我们可以从基本块中提取并维护循环内部的`headers`,`preHeader`,`enterings`,`exitings`,`latch`
等基本块和参与本层循环的基本块。同时考虑到循环的嵌套，每一个循环中还维护一个所有子循环的集合，并且维护一个本层循环的深度，方便后续对循环进行针对性优化

### 函数(Function)

函数是所有循环和基本块的承载体。

在函数中设置内部类Argument，作为函数的参数。

在函数类中，我们设计了许多方法来以函数为粒度进行操作，例如提取基本块序列，提取循环序列，提取支配关系图和支配顺序遍历基本块。考虑到函数本身的封闭性，我们约定所有value不出函数，因此每个value仅仅从属于一个function。

### 优化

为了保证原有翻译的正确性，我们不在前端生成中间代码时使用任何的优化手段，尽量保证中端绝对正确的翻译。同时，为了减少不同中端优化之间的耦合性，我们将每一种中端优化以pass的形式实现，可以方便的开关，同时保证代码编写地条理清晰。

#### DeadRetEliminate

消除函数中无用的返回值

#### RemoveBlocks

消除无用的基本块与不可达的基本块，简化控制流图

#### SimplifyCFG

简化控制流图：

- 合并基本块
- 消除只有跳转语句的基本块
- 修改跳转目标，节约跳转语句的次数

#### 冗余存储的消除

消除冗余的存储，减少访存次数，具体包括：

- 编译期间能判断无法被使用的store

#### 冗余加载的消除

消除冗余的加载，减少访存次数，具体包括：

- 编译期间能确定的Load的值
- 已经存在标量寄存器中Load的值

#### 无用指令的消除

消除无用的指令，减少指令数目

#### TailCall2Loop

尾递归优化，将尾递归优化为循环，减少函数调用的开销

#### 分支预测

对于循环中的分支，采用启发式算法，根据循环的特性进行分支预测，为后端基本块的排布服务

#### LoopSimplifyForm

将建立好的循环规约为规范形式，具体包括：

- 唯一的preheader
- 唯一的latch
- 所有的exit被header支配

将循环规约后方便其他循环优化变换

#### LCSSA

在循环的出口块插入phi指令，将循环内部变量的外部使用限定为LCSSA，方便循环优化变换

#### LoopUnswitching

循环分支提升，尽量将循环中的分支提取出来，为其他优化创造新的机会

#### LoopUnroll

分为ConstLoopUnroll和LoopUnroll

- ConstLoopUnroll：对于编译期可确定次数循环，我们首先预估展开后大小，若不超过阈值，采用全展开策略
- LoopUnroll：对于循环次数不固定的循环，目前采用4路展开策略

#### LVN

局部值编号。按照支配树进行替换，不需要多跑GCM保证正确

#### GVN

全局值编号，用于消除全局冗余计算，该算法较为经典不再赘述；进行GVN pass后需要再进行GCM pass以保证正确

#### GCM

全局代码移动。将代码在不破坏支配顺序的前提下移动到循环深度浅、支配深度深的地方

#### SCEV

参考了往年队伍CMMC和NEL的设计，在此基础上改进以识别循环中的归纳变量

#### 值域分析与强度削弱

通过rabai算法对程序变量的值域进行识别，利用该信息，对程序进行强度削弱，从而提高指令的利用效率，同时也可用于分支预测

### 后端优化

我们的编译器重视后端优化，因此针对体系结构多了许多的优化。

#### 后端优化总领

我们通过这样的思路对后端代码进行优化：寄存器分配优先，尽量减少访存，充分利用存取速度较慢的体系结构弱势，充分利用内存与cache等的思路。

#### 带权寄存器分配

我们采取了带cost的图着色寄存器分配策略，通过中端传来的循环信息在后端建立循环结构，并且根据该信息，以循环的深度和执行次数综合为寄存器进行赋值，可以保证在不得不溢出的情况下优先溢出循环深度较浅、执行次数较少的寄存器，尽可能地减少溢出带来的损失。

#### 控制流图简化

在中端和后端的前期，为了保证指令格式的简洁，约定每一个块中br指令一定在块的最末尾。但是在真正执行的时候会造成很多负面影响。因此需要对cfg进行一定程度的简化。

##### 重定向

对于所有仅有一个j指令的块，将指向它的块的指令所指向的块都换成该j指令指向的块

##### j省略

经过块重排，保证跳转概率较大的几个块大概率会依次排布，如果j的目标块就是下一个紧邻的块，就将j指令省略。

#### 访存优化

考虑到计算的局部性，可能在一个块内的集中部分会出现多次访存同一个地址的行为。在后端建立一个访存表，跟踪记录所有内存的加载情况和寄存器关联。如果某个寄存器已经存放了某一处内存的值，那么对这个内存的取就可以转化为寄存器间的移动，从而减少访存。

#### 计算优化

在后端需要尽可能多的方式对计算进行优化，减少寄存器以减少寄存器分配的压力。

其中的优化策略包括：

- 立即数加载复用(如果有较短区间内两次加载一样的数值，那么就将两条指令所用的寄存器合并)
- 地址加载复用(如果有较短区间内两次加载一样的地址，那么就将两条指令所用的寄存器合并)
- icmp+br向beq等指令转化：由于中端和后端指令含义的不同，在翻译icmp和br的时候会出现指令冗余，因此这里就将冗余指令收集并翻译为后端效果更好的beq指令，以减少指令数目

#### 乘除常数优化

考虑到riscv体系中，乘除法指令的代价非常巨大(经过实验发现,mul指令的代价为3-4条add，div的代价为10条add，rem的代价为25条add)，因此需要考虑用一系列加法和移位指令来替代常数作为参数的乘除指令

##### 乘法优化

将乘法规约为x*n，其中n为常数的格式。针对该n选择不同的指令组合。类似dp表的格式，在程序初始化的时候通过BFS计算在乘法代价内(mul_cost = 3)条指令可能产生的组合，最终可以根据其n生成一个乘法方案(mul_plan)，供优化使用

##### 除法/取余优化

本优化算法具体可以参考论文[Division by Invariant Integers using Multiplication](https://dl.acm.org/doi/10.1145/773473.178249)，即：考虑在取模的数是2的幂次的情况下，若保证被取模的数是正数，可以简便地使用andi来获取其低位数值，快速计算其模值。如果不能保证，将其转化为除法优化+相减求余数。
  - 自动向量化基础支持